col = grey(seq(1, 0, length = 256)), axes=F)
test.Y=matrix(0,nrow=N, ncol=N)
test.Z = array(0, dim=c(N,N,K))
test.beta = diag(beta.estimate)
ones=matrix(1, nrow=K, ncol=K)
eyes=diag(K)
test.beta = test.beta+epsilon*(ones-eyes)
test.theta=theta.estimate
#network prediction
for(i in 1:N){
for(j in 1:N){
if(i < j){
test.z.send.ij=rmultinom(1, size=1, prob=test.theta[i,])
test.z.recv.ij=rmultinom(1, size=1, prob=test.theta[j,])
test.z.send.ij.idx=argmax(test.z.send.ij)
test.z.recv.ij.idx=argmax(test.z.recv.ij)
test.Y[i,j]=test.Y[j,i]=rbinom(1,1,(test.beta[test.z.send.ij.idx, test.z.recv.ij.idx]))
}
}
}
#predicted theta vs true theta
image(z=t(test.theta)[1:K.true,N:1], useRaster=T, main="membership heatmap",
col = grey(seq(1, 0, length = 256)), axes=F)
image(z=t(net$mem)[1:K.true,N:1], useRaster=T, main="membership  heatmap",
col = grey(seq(1, 0, length = 256)),axes=F)
View(phi.nonlinks)
min(phi.nonlinks)
#####################################################
source("global_init.R")
source("generic_funcs.R")
source("local_init.R")
source("local_update.R")
source("global_update.R")
source("ELBO.R")
source("param_init.R")
source("anneal.R")
#####################################################
# SET UP ENVIRONMENT
#####################################################
options(digits = 10)
epsilon=1e-30
# get list of neighbors for each individual
neighbors = get.static.neighbors(adj.matrix)
# get all the unique undirected edges
links = get.links(adj.matrix) #X1 always < X2
# get the list of nonneighbors for each individual
nonneighbors=get.static.nonneighbors(adj.matrix)
# get all the undirected missing edges
nonlinks=get.nonlinks(adj.matrix)
######################################################
# INITIALIZATIONS
######################################################
K = K.true #now just for testing considered fixed
# HYPERPARAM INIT
hyper.param.init <- random.param.init(eta0=eta0, eta1=eta1, K=K, alpha)
alpha=hyper.param.init$alpha
eta0=hyper.param.init$eta0
eta1=hyper.param.init$eta1
# GLOBAL VARIATIONAL PARAMETER INIT
g.init = global.random.init(adj.matrix=adj.matrix,model.K = K.true,
eps=epsilon, eta0=eta0, eta1=eta1)
gamma=g.init$gamma.init
beta=g.init$beta.init
tau0=g.init$tau0.init
tau1=g.init$tau1.init
# LOCAL VARIATIONAL PARAMETER INIT
phi=local.init(links,K,phi.links, neighbors)
phi.links=phi[[1]]
phi.nonlinks=phi[[2]]
#####################################################
# SKIP ANNEALING FOR NOW
# ANNEALING PHASE
#####################################################
# initial.update(FIRST_CONVERGED, FIRST_MAX_ITER, K, phi.links,
#                phi.nonlinks, links, nonlinks,
#                neighbors, gamma, alpha, eta0, eta1,
#                tau0, tau1,epsilon)
#####################################################
#MAIN UPDATE
#####################################################
#First ITER values
Elog.theta=Elogp.dir(gamma)
Elog.B=Elogp.beta(tau0 = tau0, tau1 = tau1)
# STORAGE FOR ELBO AND SETTING UP CONSTANTS
#FIRST_CONVERGED=FALSE
#FIRST_MAX_ITER=1000
#MAX_ITER=65536
CONVERGED=FALSE;  MAX_ITER=1000;  iteration=1
ELBO=c(0)
ELBO.count = 2 #start from the second and then remove the first(dumb!)
min.threshold = 1e-8 #for difference between ELBO values
############################################################################
# UPDATE LOOP
############################################################################
while(!(CONVERGED) || !(iteration>MAX_ITER)){
cat(paste("iteration ",iteration,":\n"))
#####################################################
# LOCAL UPDATES
#####################################################
phi.links[,1:K] = phi.links.update(links=links, Elog.theta=Elog.theta,
Elog.B=Elog.B)
phi.nonlinks=phi.nonlinks.update(phi.links,neighbors)
#TEST:rowSums(phi.links[,-c(ncol(phi.links)-1, ncol(phi.links))])
#TEST:rowSums(phi.nonlinks)
#####################################################
#GLOBAL UPDATE
#####################################################
gamma=gamma.update(alpha,phi.links,phi.nonlinks,neighbors)
tau0=tau0.update(phi.links,eta0)
tau1=tau1.update(phi.nonlinks,links,eta1)
#####################################################
#WRITING TO FILE
#####################################################
# fileConn<-file(paste(iteration, "--output.txt"))
# writeLines(gamma[1,], fileConn)
# close(fileConn)
# Update for the next ITER
Elog.theta=Elogp.dir(gamma)
Elog.B=Elogp.beta(tau0 = tau0, tau1 = tau1)
#####################################################
#CHECKING CONVERGENCE
#####################################################
if(iteration %% 10 ==0){
cat("computing ELBO...\n")
ELBO[ELBO.count]=
compute.ELBO.E(phi.links=phi.links,phi.nonlinks=phi.nonlinks,
Elog.theta=Elog.theta, Elog.B=Elog.B,
eps=epsilon,links=links,
nonneighbors=nonneighbors,
alpha=alpha, gamma=gamma,
tau0=tau0, tau1=tau1,
eta0=eta0, eta1=eta1)
cat(paste("ELBO is ",ELBO[ELBO.count],"\n"))
if(abs(ELBO[ELBO.count]-ELBO[ELBO.count-1]) < min.threshold){
CONVERGED=TRUE
cat("ELBO has converged!!!\n")
break;
}
ELBO.count=ELBO.count+1
}
iteration=iteration+1
if(iteration >= MAX_ITER){
cat("MAX_ITER reached and not converged:(!!\n")
break;
}
#####################################################
# END OF LOOP
}
###################################################
ELBO=ELBO[-1] #throws away the 0 in the beginning
###################################################
#####################################################
#PLOT OF THE ELBO
#####################################################
plot(1:length(ELBO),ELBO,type = 'l') # ELBO
######SKIP THIS FOR NOW###################################################
# library(maxLik)
# elbo.m.alpha  <- function(alpha){
#     compute.ELBO.E(phi.links=phi.links,phi.nonlinks=phi.nonlinks,
#                    Elog.theta=Elog.theta, Elog.B=Elog.B,
#                    eps=epsilon,links=links,
#                    nonneighbors=nonneighbors,alpha, gamma=gamma,
#                    tau0=tau0, tau1=tau1, eta0=eta0, eta1=eta1)
# }
# x=maxLik(logLik = elbo.m.alpha, start = rep(0.1, K), method = "nr")
# x$maximum
# alpha=x$estimate
# ########################################################################
View(phi.nonlinks)
summary(phi.nonlinks)
options(digits = 22)
a=2
a
a=2.0
a
options(digits = 10)
rm(list=ls())
options(digits=10)
source("generic_funcs.R")
source("genr_network.R")
library(fields)
N=200;K.true=2
eta0 = 10;eta1 = 1.0
#alpha=rep(1.0/K.true, K.true)
alpha=rep(0.05, K.true)
net=genr_network(alpha = alpha, N = N, eta0 = eta0, eta1 = eta1)
adj.matrix=net$net
model.K = K.true
#network
plot.igraph(graph.adjacency(net$net, mode='undirected'),
layout=layout.fruchterman.reingold, vertex.size=5)
#theta's
image(z=t(net$mem)[1:K.true,N:1], useRaster=T,
col = grey(seq(1, 0, length = 256)), axes=F )
#adj.matrix
image(z=adj.matrix[1:N,N:1],
col = grey(seq(1, 0, length = 256)), axes=F, main="adjacency matrix")
#Beta
image(z=net$Beta[1:K.true,K.true:1],
col = grey(seq(1, 0, length = 256)), axes=F, main="Compatibility matrix")
#alpha
barplot(alpha, names.arg = seq(1,K.true, by=1),
main="Alpha for each community")
#####################################################
source("global_init.R")
source("generic_funcs.R")
source("local_init.R")
source("local_update.R")
source("global_update.R")
source("ELBO.R")
source("param_init.R")
source("anneal.R")
#####################################################
# SET UP ENVIRONMENT
#####################################################
options(digits = 10)
epsilon=1e-30
# get list of neighbors for each individual
neighbors = get.static.neighbors(adj.matrix)
# get all the unique undirected edges
links = get.links(adj.matrix) #X1 always < X2
# get the list of nonneighbors for each individual
nonneighbors=get.static.nonneighbors(adj.matrix)
# get all the undirected missing edges
nonlinks=get.nonlinks(adj.matrix)
######################################################
# INITIALIZATIONS
######################################################
K = K.true #now just for testing considered fixed
# HYPERPARAM INIT
hyper.param.init <- random.param.init(eta0=eta0, eta1=eta1, K=K, alpha)
alpha=hyper.param.init$alpha
eta0=hyper.param.init$eta0
eta1=hyper.param.init$eta1
# GLOBAL VARIATIONAL PARAMETER INIT
g.init = global.random.init(adj.matrix=adj.matrix,model.K = K.true,
eps=epsilon, eta0=eta0, eta1=eta1)
gamma=g.init$gamma.init
beta=g.init$beta.init
tau0=g.init$tau0.init
tau1=g.init$tau1.init
# LOCAL VARIATIONAL PARAMETER INIT
phi=local.init(links,K,phi.links, neighbors)
phi.links=phi[[1]]
phi.nonlinks=phi[[2]]
#####################################################
# SKIP ANNEALING FOR NOW
# ANNEALING PHASE
#####################################################
# initial.update(FIRST_CONVERGED, FIRST_MAX_ITER, K, phi.links,
#                phi.nonlinks, links, nonlinks,
#                neighbors, gamma, alpha, eta0, eta1,
#                tau0, tau1,epsilon)
#####################################################
#MAIN UPDATE
#####################################################
#First ITER values
Elog.theta=Elogp.dir(gamma)
Elog.B=Elogp.beta(tau0 = tau0, tau1 = tau1)
# STORAGE FOR ELBO AND SETTING UP CONSTANTS
#FIRST_CONVERGED=FALSE
#FIRST_MAX_ITER=1000
#MAX_ITER=65536
CONVERGED=FALSE;  MAX_ITER=1000;  iteration=1
ELBO=c(0)
ELBO.count = 2 #start from the second and then remove the first(dumb!)
min.threshold = 1e-8 #for difference between ELBO values
############################################################################
# UPDATE LOOP
############################################################################
while(!(CONVERGED) || !(iteration>MAX_ITER)){
cat(paste("iteration ",iteration,":\n"))
#####################################################
# LOCAL UPDATES
#####################################################
phi.links[,1:K] = phi.links.update(links=links, Elog.theta=Elog.theta,
Elog.B=Elog.B)
phi.nonlinks=phi.nonlinks.update(phi.links,neighbors)
#TEST:rowSums(phi.links[,-c(ncol(phi.links)-1, ncol(phi.links))])
#TEST:rowSums(phi.nonlinks)
#####################################################
#GLOBAL UPDATE
#####################################################
gamma=gamma.update(alpha,phi.links,phi.nonlinks,neighbors)
tau0=tau0.update(phi.links,eta0)
tau1=tau1.update(phi.nonlinks,links,eta1)
#####################################################
#WRITING TO FILE
#####################################################
# fileConn<-file(paste(iteration, "--output.txt"))
# writeLines(gamma[1,], fileConn)
# close(fileConn)
# Update for the next ITER
Elog.theta=Elogp.dir(gamma)
Elog.B=Elogp.beta(tau0 = tau0, tau1 = tau1)
#####################################################
#CHECKING CONVERGENCE
#####################################################
if(iteration %% 10 ==0){
cat("computing ELBO...\n")
ELBO[ELBO.count]=
compute.ELBO.E(phi.links=phi.links,phi.nonlinks=phi.nonlinks,
Elog.theta=Elog.theta, Elog.B=Elog.B,
eps=epsilon,links=links,
nonneighbors=nonneighbors,
alpha=alpha, gamma=gamma,
tau0=tau0, tau1=tau1,
eta0=eta0, eta1=eta1)
cat(paste("ELBO is ",ELBO[ELBO.count],"\n"))
if(abs(ELBO[ELBO.count]-ELBO[ELBO.count-1]) < min.threshold){
CONVERGED=TRUE
cat("ELBO has converged!!!\n")
break;
}
ELBO.count=ELBO.count+1
}
iteration=iteration+1
if(iteration >= MAX_ITER){
cat("MAX_ITER reached and not converged:(!!\n")
break;
}
#####################################################
# END OF LOOP
}
###################################################
ELBO=ELBO[-1] #throws away the 0 in the beginning
###################################################
#####################################################
#PLOT OF THE ELBO
#####################################################
plot(1:length(ELBO),ELBO,type = 'l') # ELBO
######SKIP THIS FOR NOW###################################################
# library(maxLik)
# elbo.m.alpha  <- function(alpha){
#     compute.ELBO.E(phi.links=phi.links,phi.nonlinks=phi.nonlinks,
#                    Elog.theta=Elog.theta, Elog.B=Elog.B,
#                    eps=epsilon,links=links,
#                    nonneighbors=nonneighbors,alpha, gamma=gamma,
#                    tau0=tau0, tau1=tau1, eta0=eta0, eta1=eta1)
# }
# x=maxLik(logLik = elbo.m.alpha, start = rep(0.1, K), method = "nr")
# x$maximum
# alpha=x$estimate
# ########################################################################
rm(list=ls())
options(digits=10)
source("generic_funcs.R")
source("genr_network.R")
library(fields)
N=200;K.true=2
eta0 = 10;eta1 = 1.0
#alpha=rep(1.0/K.true, K.true)
alpha=rep(0.05, K.true)
net=genr_network(alpha = alpha, N = N, eta0 = eta0, eta1 = eta1)
adj.matrix=net$net
model.K = K.true
#network
plot.igraph(graph.adjacency(net$net, mode='undirected'),
layout=layout.fruchterman.reingold, vertex.size=5)
#theta's
image(z=t(net$mem)[1:K.true,N:1], useRaster=T,
col = grey(seq(1, 0, length = 256)), axes=F )
#adj.matrix
image(z=adj.matrix[1:N,N:1],
col = grey(seq(1, 0, length = 256)), axes=F, main="adjacency matrix")
#Beta
image(z=net$Beta[1:K.true,K.true:1],
col = grey(seq(1, 0, length = 256)), axes=F, main="Compatibility matrix")
#alpha
barplot(alpha, names.arg = seq(1,K.true, by=1),
main="Alpha for each community")
#####################################################
source("global_init.R")
source("generic_funcs.R")
source("local_init.R")
source("local_update.R")
source("global_update.R")
source("ELBO.R")
source("param_init.R")
source("anneal.R")
#####################################################
# SET UP ENVIRONMENT
#####################################################
options(digits = 10)
epsilon=1e-30
# get list of neighbors for each individual
neighbors = get.static.neighbors(adj.matrix)
# get all the unique undirected edges
links = get.links(adj.matrix) #X1 always < X2
# get the list of nonneighbors for each individual
nonneighbors=get.static.nonneighbors(adj.matrix)
# get all the undirected missing edges
nonlinks=get.nonlinks(adj.matrix)
######################################################
# INITIALIZATIONS
######################################################
K = K.true #now just for testing considered fixed
# HYPERPARAM INIT
hyper.param.init <- random.param.init(eta0=eta0, eta1=eta1, K=K, alpha)
alpha=hyper.param.init$alpha
eta0=hyper.param.init$eta0
eta1=hyper.param.init$eta1
# GLOBAL VARIATIONAL PARAMETER INIT
g.init = global.random.init(adj.matrix=adj.matrix,model.K = K.true,
eps=epsilon, eta0=eta0, eta1=eta1)
gamma=g.init$gamma.init
beta=g.init$beta.init
tau0=g.init$tau0.init
tau1=g.init$tau1.init
# LOCAL VARIATIONAL PARAMETER INIT
phi=local.init(links,K,phi.links, neighbors)
phi.links=phi[[1]]
phi.nonlinks=phi[[2]]
#####################################################
# SKIP ANNEALING FOR NOW
# ANNEALING PHASE
#####################################################
# initial.update(FIRST_CONVERGED, FIRST_MAX_ITER, K, phi.links,
#                phi.nonlinks, links, nonlinks,
#                neighbors, gamma, alpha, eta0, eta1,
#                tau0, tau1,epsilon)
#####################################################
#MAIN UPDATE
#####################################################
#First ITER values
Elog.theta=Elogp.dir(gamma)
Elog.B=Elogp.beta(tau0 = tau0, tau1 = tau1)
# STORAGE FOR ELBO AND SETTING UP CONSTANTS
#FIRST_CONVERGED=FALSE
#FIRST_MAX_ITER=1000
#MAX_ITER=65536
CONVERGED=FALSE;  MAX_ITER=1000;  iteration=1
ELBO=c(0)
ELBO.count = 2 #start from the second and then remove the first(dumb!)
min.threshold = 1e-8 #for difference between ELBO values
############################################################################
# UPDATE LOOP
############################################################################
while(!(CONVERGED) || !(iteration>MAX_ITER)){
cat(paste("iteration ",iteration,":\n"))
#####################################################
# LOCAL UPDATES
#####################################################
phi.links[,1:K] = phi.links.update(links=links, Elog.theta=Elog.theta,
Elog.B=Elog.B)
phi.nonlinks=phi.nonlinks.update(phi.links,neighbors)
#TEST:rowSums(phi.links[,-c(ncol(phi.links)-1, ncol(phi.links))])
#TEST:rowSums(phi.nonlinks)
#####################################################
#GLOBAL UPDATE
#####################################################
gamma=gamma.update(alpha,phi.links,phi.nonlinks,neighbors)
tau0=tau0.update(phi.links,eta0)
tau1=tau1.update(phi.nonlinks,links,eta1)
#####################################################
#WRITING TO FILE
#####################################################
# fileConn<-file(paste(iteration, "--output.txt"))
# writeLines(gamma[1,], fileConn)
# close(fileConn)
# Update for the next ITER
Elog.theta=Elogp.dir(gamma)
Elog.B=Elogp.beta(tau0 = tau0, tau1 = tau1)
#####################################################
#CHECKING CONVERGENCE
#####################################################
if(iteration %% 10 ==0){
cat("computing ELBO...\n")
ELBO[ELBO.count]=
compute.ELBO.E(phi.links=phi.links,phi.nonlinks=phi.nonlinks,
Elog.theta=Elog.theta, Elog.B=Elog.B,
eps=epsilon,links=links,
nonneighbors=nonneighbors,
alpha=alpha, gamma=gamma,
tau0=tau0, tau1=tau1,
eta0=eta0, eta1=eta1)
cat(paste("ELBO is ",ELBO[ELBO.count],"\n"))
if(abs(ELBO[ELBO.count]-ELBO[ELBO.count-1]) < min.threshold){
CONVERGED=TRUE
cat("ELBO has converged!!!\n")
break;
}
ELBO.count=ELBO.count+1
}
iteration=iteration+1
if(iteration >= MAX_ITER){
cat("MAX_ITER reached and not converged:(!!\n")
break;
}
#####################################################
# END OF LOOP
}
###################################################
ELBO=ELBO[-1] #throws away the 0 in the beginning
###################################################
#####################################################
#PLOT OF THE ELBO
#####################################################
plot(1:length(ELBO),ELBO,type = 'l') # ELBO
######SKIP THIS FOR NOW###################################################
# library(maxLik)
# elbo.m.alpha  <- function(alpha){
#     compute.ELBO.E(phi.links=phi.links,phi.nonlinks=phi.nonlinks,
#                    Elog.theta=Elog.theta, Elog.B=Elog.B,
#                    eps=epsilon,links=links,
#                    nonneighbors=nonneighbors,alpha, gamma=gamma,
#                    tau0=tau0, tau1=tau1, eta0=eta0, eta1=eta1)
# }
# x=maxLik(logLik = elbo.m.alpha, start = rep(0.1, K), method = "nr")
# x$maximum
# alpha=x$estimate
# ########################################################################
